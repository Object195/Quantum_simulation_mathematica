(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["Spin`"]*)
(*Unprotect@@Names["Spin`*"];*)
(*ClearAll@@Names["Spin`*"];*)
(*(*ClearAll[\[Sigma]xi,\[Sigma]yi,\[Sigma]zi,upstate,downstate,\[Sigma]x,\[Sigma]y,\[Sigma]z,Operatorlist,Statelist]*)*)
(*\[Sigma]xi::usage="*)
(*\[Sigma]xi[N_,i_]*)
(**)
(*computes tensor product representation of \[Sigma]x operator acting on spin i.*)
(* N: total number of spin*)
(* i: index of spin space the operator is acting on (1<= i <= N).*)
(*";*)
(*\[Sigma]yi::usage="*)
(*\[Sigma]yi[N_,i_]*)
(*computes tensor product representation of \[Sigma]y operator acting on spin i.*)
(* N: total number of spin*)
(* i: index of spin space the operator is acting on (1<= i <= N).*)
(*";*)
(*\[Sigma]zi::usage="*)
(*\[Sigma]zi[N_,i_]*)
(**)
(*computes tensor product representation of \[Sigma]z operator acting on spin i.*)
(* N: total number of spin*)
(* i: index of spin space the operator is acting on (1<= i <= N).*)
(*";*)
(*sket::usage="*)
(*sket[N_,i_]*)
(*computes tensor product representation of spin ket.*)
(**)
(*N: total number of spin*)
(*state: array of integers specifying the spin of each space, *)
(*0 for up, 1 for down*)
(*";*)
(*Begin["`Private`"]*)
(**)
(*(*Basic matrix/state*)*)
(*\[Sigma]x={{0,1},{1,0}};\[Sigma]y={{0,-I},{I,0}};\[Sigma]z={{1,0},{0,-1}};*)
(*upstate={1,0};downstate={0,1};*)
(**)
(*Operatorlist[N_,i_,mat_]:=ReplacePart[Table[IdentityMatrix[2],{j,1,N}],{i}->mat];*)
(**)
(*Statelist[N_,state_]:=ReplacePart[Table[upstate,{j,1,N}],*)
(*Position[state,1]->downstate];*)
(*(*Generate operators in tensor product basis, N for total number of spin, i for the index of spin*)
(*space the operator is acting on (1~N)*)*)
(*\[Sigma]xi[N_,i_]:=Module[{list=Operatorlist[N,i,\[Sigma]x],nmat=Operatorlist[N,i,\[Sigma]x][[1]]},Do[nmat=KroneckerProduct[nmat,list[[j+1]]],{j,1,N-1}];nmat]*)
(**)
(*\[Sigma]yi[N_,i_]:=Module[{list=Operatorlist[N,i,\[Sigma]y],nmat=Operatorlist[N,i,\[Sigma]y][[1]]},Do[nmat=KroneckerProduct[nmat,list[[j+1]]],{j,1,N-1}];nmat]*)
(**)
(*\[Sigma]zi[N_,i_]:=Module[{list=Operatorlist[N,i,\[Sigma]z],nmat=Operatorlist[N,i,\[Sigma]z][[1]]},Do[nmat=KroneckerProduct[nmat,list[[j+1]]],{j,1,N-1}];nmat]*)
(**)
(*(*Generate kets in tensor product basis, N for total number of spin, state is an array of integers specifying the spin of each space, 0 for up, 1 for down*)*)
(*sket[N_,state_]:=Module[{list=Statelist[N,state],nket=Statelist[N,state][[1]]},Do[nket=KroneckerProduct[nket,list[[j+1]]],{j,1,N-1}];Flatten[nket]]*)
(*End[] *)
(*Protect@@Names["Spin`*"];*)
(*EndPackage[]*)


(* ::Input:: *)
(*(*test*)*)
(*(*MatrixForm[\[Sigma]xi[3,1]]*)
(*MatrixForm[\[Sigma]yi[3,1]]*)
(*MatrixForm[\[Sigma]zi[3,1]]*)*)


(* ::Input:: *)
(*(*MatrixForm[\[Sigma]xi[3,3]]*)
(*MatrixForm[\[Sigma]yi[3,3]]*)
(*MatrixForm[\[Sigma]zi[3,3]]*)*)


(* ::Input:: *)
(*(*sket[3,{0,0,0}]*)
(*sket[3,{1,0,0}]*)
(*\[Sigma]xi[3,1].sket[3,{0,0,0}]*)*)
